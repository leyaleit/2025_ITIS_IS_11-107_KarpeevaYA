Многопоточность — Википедия Многопоточность Материал из Википедии — свободной энциклопедии Перейти к навигации Перейти к поиску Не следует путать со Многоядерность . Многопото́чность ( англ. Multithreading ) — свойство платформы (например, операционной системы , виртуальной машины и т. д.) или приложения , состоящее в том, что процесс , порождённый в операционной системе, может состоять из нескольких потоков , выполняющихся « параллельно », то есть без предписанного порядка во времени . При выполнении некоторых задач такое разделение может достичь более эффективного использования ресурсов вычислительной машины . Такие потоки называют также потоками выполнения (от англ. thread of execution ); иногда называют «нитями» (буквальный перевод англ. thread ) или неформально «тредами». Содержание 1 Описание 2 Аппаратная реализация 3 Типы реализации потоков 4 Взаимодействие потоков 5 Критика терминологии 6 См. также 7 Литература 8 Примечания 9 Ссылки Описание [ править | править код ] Сутью многопоточности является квазимногозадачность на уровне одного исполняемого процесса, то есть все потоки выполняются в адресном пространстве процесса. Кроме этого, все потоки процесса имеют не только общее адресное пространство, но и общие дескрипторы файлов . Выполняющийся процесс имеет как минимум один (главный) поток. Многопоточность (как доктрину программирования ) не следует путать ни с многозадачностью , ни с многопроцессорностью , несмотря на то, что операционные системы , реализующие многозадачность , как правило, реализуют и многопоточность. К достоинствам многопоточной реализации той или иной системы перед многозадачной можно отнести следующее: Упрощение программы в некоторых случаях за счёт использования общего адресного пространства. Меньшие относительно процесса временны́е затраты на создание потока. К достоинствам многопоточной реализации той или иной системы перед однопоточной можно отнести следующее: Упрощение программы в некоторых случаях, за счёт вынесения механизмов чередования выполнения различных слабо взаимосвязанных подзадач, требующих одновременного выполнения, в отдельную подсистему многопоточности. Повышение производительности процесса за счёт распараллеливания процессорных вычислений и операций ввода-вывода. В случае, если потоки выполнения требуют относительно сложного взаимодействия друг с другом, возможно проявление проблем многозадачности, таких как взаимные блокировки. Аппаратная реализация [ править | править код ] На обычном процессоре управление потоками осуществляется операционной системой. Поток исполняется до тех пор, пока не произойдёт аппаратное прерывание, системный вызов или пока не истечёт отведённое для него операционной системой время. После этого процессор переключается на код операционной системы, который сохраняет состояние потока (его контекст) или переключается на состояние другого потока, которому тоже выделяется время на исполнение. При такой многопоточности достаточно большое количество тактов процессора тратится на код операционной системы, переключающий контексты. Если поддержку потоков реализовать аппаратно, то процессор сам сможет переключаться между потоками, а в идеальном случае - выполнять несколько потоков одновременно за каждый такт. Для операционной системы и пользователя один такой физический процессор будет виден как несколько логических процессоров. Различают две формы многопоточности, которые могут быть реализованы в процессорах аппаратно: Временная многопоточность ( англ. Temporal multithreading ) Одновременная многопоточность ( англ. Simultaneous multithreading ) Типы реализации потоков [ править | править код ] Основная статья: Поток выполнения Поток в пространстве пользователя. Каждый процесс имеет таблицу потоков, аналогичную таблице процессов ядра. К недостаткам можно отнести: Отсутствие прерывания по таймеру внутри одного процесса При использовании блокирующего системного запроса для процесса все его потоки блокируются. Сложность реализации Поток в пространстве ядра. Наряду с таблицей процессов в пространстве ядра имеется таблица потоков. «Волокна» ( англ. fibers ). Несколько потоков режима пользователя, исполняющихся в одном потоке режима ядра. Поток пространства ядра потребляет заметные ресурсы, в первую очередь физическую память и диапазон адресов режима ядра для стека режима ядра. Поэтому было введено понятие «волокна» — облегчённого потока, выполняемого исключительно в режиме пользователя. У каждого потока может быть несколько «волокон». Взаимодействие потоков [ править | править код ] В многопоточной среде часто возникают задачи, требующие приостановки и возобновления работы одних потоков в зависимости от работы других. В частности это задачи, связанные с предотвращением конфликтов доступа при использовании одних и тех же данных или устройств из параллельно исполняемых потоков. Для решения таких задач используются специальные объекты для взаимодействия потоков, такие как взаимоисключения (мьютексы), семафоры, критические секции, события и т.п. Многие из этих объектов являются объектами ядра и могут применяться не только между потоками одного процесса, но и для взаимодействия между потоками разных процессов. Взаимоисключения (mutex, мьютекс ) — это объект синхронизации, который устанавливается в особое сигнальное состояние, когда не занят каким-либо потоком. Только один поток владеет этим объектом в любой момент времени, отсюда и название таких объектов (от английского mut ually ex clusive access — взаимно исключающий доступ) — одновременный доступ к общему ресурсу исключается. После всех необходимых действий мьютекс освобождается, предоставляя другим потокам доступ к общему ресурсу. Объект может поддерживать рекурсивный захват второй раз тем же потоком, увеличивая счётчик, не блокируя поток, и требуя потом многократного освобождения. Такова, например, критическая секция в Win32 . Тем не менее, есть и такие реализации, которые не поддерживают такое и приводят к взаимной блокировке потока при попытке рекурсивного захвата. Например, это FAST_MUTEX в ядре Windows. Критические секции обеспечивают синхронизацию подобно мьютексам, за исключением того, что объекты, представляющие критические секции, доступны лишь в пределах одного процесса. События, мьютексы и семафоры также можно использовать в потоках однопроцессного приложения, однако реализации критических секций в некоторых ОС (например, Windows NT) обеспечивают более быстрый и более эффективный [ 1 ] [ 2 ] механизм взаимно-исключающей синхронизации — операции «получить» и «освободить» на критической секции оптимизированы для случая единственного потока (отсутствия конкуренции) с целью избежать любых ведущих в ядро ОС системных вызовов. Семафоры представляют собой доступные ресурсы, которые могут быть приобретены несколькими потоками в одно и то же время, пока пул ресурсов не опустеет. Тогда дополнительные потоки должны ждать, пока требуемое количество ресурсов не будет снова доступно. События. Объект, хранящий в себе 1 бит информации «просигнализирован или нет», над которым определены операции «просигнализировать», «сбросить в непросигнализированное состояние» и «ожидать». Ожидание на просигнализированном событии есть отсутствие операции с немедленным продолжением исполнения потока. Ожидание на непросигнализированном событии приводит к приостановке исполнения потока до тех пор, пока другой поток (или же вторая фаза обработчика прерывания в ядре ОС) не просигнализирует событие. Возможно ожидание нескольких событий в режимах «любого» или «всех». Возможно также создание события, автоматически сбрасываемого в непросигнализированное состояние после пробуждения первого же — и единственного — ожидающего потока (такой объект используется как основа для реализации объекта «критическая секция»). Активно используются в MS Windows, как в режиме пользователя, так и в режиме ядра. Условные переменные (condvars). Сходны с событиями, но не являются объектами, занимающими память — используется только адрес переменной, понятие «содержимое переменной» не существует, в качестве условной переменной может использоваться адрес произвольного объекта. В отличие от событий, установка условной переменной в просигнализированное состояние не влечёт за собой никаких последствий в случае, если на данный момент нет потоков, ожидающих на переменной. Установка события в аналогичном случае влечёт за собой запоминание состояния «просигнализировано» внутри самого события, после чего следующие потоки, желающие ожидать события, продолжают исполнение немедленно без остановки. Для полноценного использования такого объекта необходима также операция «освободить mutex и ожидать условную переменную атомарно». Активно используются в UNIX -подобных ОС. Дискуссии о преимуществах и недостатках событий и условных переменных являются заметной частью дискуссий о преимуществах и недостатках Windows и UNIX. Порт завершения ввода-вывода (IO completion port, IOCP). Реализованный в ядре ОС и доступный через системные вызовы объект «очередь» с операциями «поместить структуру в хвост очереди» и «взять следующую структуру из головы очереди» — последний вызов приостанавливает исполнение потока в случае, если очередь пуста, и до тех пор, пока другой поток не осуществит вызов «поместить». Самой важной особенностью IOCP является то, что структуры в него могут помещаться не только явным системным вызовом из режима пользователя, но и неявно внутри ядра ОС как результат завершения асинхронной операции ввода-вывода на одном из дескрипторов файлов. Для достижения такого эффекта необходимо использовать системный вызов «связать дескриптор файла с IOCP». В этом случае помещенная в очередь структура содержит в себе код ошибки операции ввода-вывода, а также, для случая успеха этой операции — число реально введённых или выведенных байт. Реализация порта завершения также ограничивает число потоков, исполняющихся на одном процессоре/ядре после получения структуры из очереди. Объект специфичен для MS Windows и позволяет обрабатывать входящие запросы соединения и порций данных в серверном программном обеспечении в архитектуре, где число потоков может быть меньше числа клиентов (нет требования создавать отдельный поток с расходами ресурсов на него для каждого нового клиента). ERESOURCE. Мьютекс, поддерживающий рекурсивный захват, с семантикой разделяемого или эксклюзивного захвата. Семантика: объект может быть либо свободен, либо захвачен произвольным числом потоков разделяемым образом, либо захвачен всего одним потоком эксклюзивным образом. Любые попытки осуществить захваты, нарушающее это правило, приводят к блокировке потока до тех пор, пока объект не освободится так, чтобы сделать захват разрешённым. Также есть операции вида TryToAcquire — никогда не блокирует поток, либо захватывает, либо (если нужна блокировка) возвращает FALSE, ничего не делая. Используется в ядре Windows, особенно в файловых системах — так, например, любому кем-то открытому дисковому файлу соответствует структура FCB, в которой есть 2 таких объекта для синхронизации доступа к размеру файла. Один из них — paging IO resource — захватывается эксклюзивно только в пути обрезания файла, и гарантирует, что в момент обрезания на файле нет активного ввода-вывода от кэша и от отображения в память. Rundown protection . Полудокументированный (вызовы присутствуют в файлах-заголовках, но отсутствуют в документации) объект в ядре Windows. Счётчик с операциями «увеличить», «уменьшить» и «ждать». Ожидание блокирует поток до тех пор, пока операции уменьшения не уменьшат счётчик до нуля. Кроме того, операция увеличения может отказать, и наличие активного в данный момент времени ожидания заставляет отказывать все операции увеличения. Критика терминологии [ править | править код ] Перевод английского термина thread как «поток» в контексте, связанном с программированием, противоречит его же переводу «нить» в общеязыковом контексте, а также создаёт коллизии с термином Data stream . Однако термин «поток» связан с переводами иностранной технической литературы, выполненными в 1970-х годах издательством «Мир». В настоящее время в «академических кругах» (то есть в учебниках, методических пособиях, курсах вузов, диссертациях и пр.) он считается эталонным. Термины же «нить», «тред» и т. п. считаются техническими жаргонизмами . См. также [ править | править код ] Hyper-threading Литература [ править | править код ] Kunle Olukotun. Chip Multiprocessor Architecture - Techniques to Improve Throughput and Latency . — Morgan and Claypool Publishers, 2007. — 154 p. — ISBN 159829122X . (англ.) Mario Nemirovsky, Dean M. Tullsen. Multithreading Architecture. — Morgan and Claypool Publishers, 2013. — 1608458555 p. — ISBN 1608458555 . (англ.) Примечания [ править | править код ] ↑ Jeffrey Richter . "Джеффри Рихтер. Windows для профессионалов. Создание эффективных WIN32-приложений с учетом специфики 64-разрядной версии Windows. 2001 год ↑ MSDN http://msdn.microsoft.com/en-us/library/ms682530%28VS.85%29.aspx Архивная копия от 23 декабря 2011 на Wayback Machine Ссылки [ править | править код ] Введение в технологии параллельного программирования (рус.) https://web.archive.org/web/20050505155716/http://hardclub.donntu.edu.ua/projects/qt/qq/qq11-mutex.html#understandingmutexesandsemaphores Введение в многопоточность Технологии цифровых процессоров Архитектура Гарвардская Фон Неймана TTA Архитектура набора команд ARM ASIP EDGE TRIPS EPIC CISC MISC NISC URISC RISC VLIW ZISC Машинное слово 8 бит 16 бит 32 бит 64 бит 128 бит 256 бит 512 бит Параллелизм Конвейер Конвейер Внеочередное исполнение Переименование регистров Спекулятивное исполнение Предсказатель переходов Предвыборка кода Уровни Бит Инструкций Суперскалярность Данных Задач Потоки Многопоточность Superthreading Одновременная многопоточность Hyperthreading Аппаратная виртуализация Классификация Флинна SISD SIMD MISD MIMD Реализации DSP GPU SoC PPU Векторный Матричный Математический сопроцессор Микропроцессор Микроконтроллер Барабанный процессор Сетевой Нейронный Процессор машинного зрения Тензорный процессор Google TrueNorth Компоненты Barrel shifter FPU BSB MMU TLB Устройство управления АЛУ Демультиплексор Мультиплексор Микрокод Тактовая частота Корпус Кэш Кэш процессора Регистры Регистровый файл Регистровое окно Регистр флагов Индексный регистр Счётчик команд Аккумулятор Управление питанием APM ACPI Clock gating Троттлинг Динамическое изменение напряжения Аспекты операционных систем Сравнение [англ.] Доля использования [англ.] История Типы Встраиваемая Распределённая [англ.] ОС суперкомпьютера [англ.] ОС реального времени Сетевая Мобильная Ядро Архитектура Монолитное Гибридное Виртуальное [англ.] Rump kernel [англ.] Микро- Нано- Экзо- Уни- Компоненты Модуль ядра Драйвер Режим ядра Пользовательское пространство Управление процессами Концепции Многопоточность мультипрограммирование Многозадачность вытесняющая кооперативная Планировщик задач Переключение контекста Прерывание IPC PCB Система реального времени Поток выполнения Разделение времени Алгоритмы планирования Упреждающее планирование с фиксированным приоритетом [англ.] Многоуровневые очереди с обратной связью [англ.] RR SJN SRT FIFO LIFO Управление и адресация памяти Файл Отображение в память Файлы устройств Файловая система Атрибуты файлов Журналирование inode Общий ресурс Стек Куча Кэш Сжатие Шифрование Защита Кольца защиты Сегментная адресация Сегментация Дефрагментация Страничная память Подкачка страниц Виртуальная память Менеджер виртуальной памяти VFS Ошибка сегментации Ошибка на шине [англ.] Общая ошибка защиты [англ.] Средства загрузки и инициализации BIOS EFI PXE MBR GPT Live CD Live USB Загрузчик ОС Подсистема инициализации Прочее Ввод-вывод Оболочка Интерпретатор командной строки API Системные вызовы Цикл событий Обмен сообщениями HAL Вычислительная сеть Категория Викисклад Викиучебник Викисловарь Параллельные вычисления Общие положения Высокопроизводительные вычисления Кластерные вычисления Распределённые вычисления Грид-вычисления Туманные вычисления Уровни параллелизма Биты Инструкции Данные Задачи Циклы Поток выполнения Суперпоточность Гиперпоточность Теория Закон Амдала Закон Густавсона — Барсиса Эффективность затрат Метрика Карпа — Флэтта Замедление Коэффициент ускорения Элементы Процесс Поток Файбер ПМПД Instruction window Взаимодействие Многопроцессорность Многозадачность ( Вытесняющая многозадачность Кооперативная многозадачность ) Многопоточность Когерентность памяти Когерентность кэша Недействительность кэша Барьер Программирование Модели ( Скрытый параллелизм Явный параллелизм Параллелизм ) Таксономия Флинна SISD SIMD MISD MIMD SPMD Поток Неблокирующая синхронизация Компьютерная техника Мультипроцессорность ( Симметричная Асимметричная ) Память ( NUMA COMA Распределённая Разделяемая Распределённая разделяемая Транзакционная ) Одновременная многопоточность MPP Суперскалярность Векторный процессор Матричный процессор Суперкомпьютер Beowulf API Ateji PX POSIX Threads OpenMP OpenHMPP PVM MPI UPC Intel Threading Building Blocks Boost Global Arrays Charm++ Cilk Co-array Fortran OpenCL CUDA FireStream Dryad DryadLINQ Проблемы Затруднительное распараллеливание Чрезвычайная параллельность Проблемы Великого Вызова Блокировка ПО Масштабируемость Состояние гонки Взаимная блокировка Активный тупик Детерминированный алгоритм Параллельное замедление Источник — https://ru.wikipedia.org/w/index.php?title=Многопоточность&oldid=139364618 Категории : Технологии процессоров Операционная система Параллельные вычисления Концепции языков программирования Скрытая категория: Страницы, использующие волшебные ссылки ISBN Навигация Поиск