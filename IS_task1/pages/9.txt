Функциональное программирование — Википедия Функциональное программирование Материал из Википедии — свободной энциклопедии Перейти к навигации Перейти к поиску Парадигмы программирования Императивная (контрастирует с декларативной ) Процедурная Структурная Аспектно-ориентированная Объектно-ориентированная Агентно-ориентированная Компонентно-ориентированная Прототипно-ориентированная Обобщённое программирование Декларативная (контрастирует с императивной ) Чистота языка Чистота функции Функциональная В терминах рефал-машины Аппликативная Комбинаторная Бесточечная ( чистая конкатенативная ) Логическая Ограничениями Конкатенативная Векторная [англ.] Метапрограммирование Языково-ориентированная Предметно-ориентированная Пользователями Автоматизация процесса программирования Рефлексивность Гомоикони́чность Связанные темы Программирование в крупном и мелком масштабе [англ.] Модульность Полиморфизм Продолжения и CPS Параллелизм Методы и алгоритмы Автоматное Потоков данных Событийно-ориентированное Реактивное Сервис-ориентированное Функциона́льное программи́рование — парадигма программирования , в которой процесс вычисления трактуется как вычисление значений функций в математическом понимании последних (в отличие от функций как подпрограмм в процедурном программировании ). Противопоставляется парадигме императивного программирования , которая описывает процесс вычислений как последовательное изменение состояний (в значении, подобном таковому в теории автоматов ). При необходимости, в функциональном программировании вся совокупность последовательных состояний вычислительного процесса представляется явным образом, например, как список . Функциональное программирование предполагает обходиться вычислением результатов функций от исходных данных и результатов других функций, и не предполагает явного хранения состояния программы. Соответственно, не предполагает оно и изменяемость этого состояния (в отличие от императивного , где одной из базовых концепций является переменная , хранящая своё значение и позволяющая менять его по мере выполнения алгоритма . На практике отличие математической функции от понятия «функции» в императивном программировании заключается в том, что императивные функции могут опираться не только на аргументы, но и на состояние внешних по отношению к функции переменных, а также иметь побочные эффекты и менять состояние внешних переменных. Таким образом, в императивном программировании при вызове одной и той же функции с одинаковыми параметрами, но на разных этапах выполнения алгоритма, можно получить разные данные на выходе из-за влияния на функцию состояния переменных. А в функциональном языке при вызове функции с одними и теми же аргументами мы всегда получим одинаковый результат: выходные данные зависят только от входных. Это позволяет средам выполнения программ на функциональных языках кешировать результаты функций и вызывать их в порядке, не определяемом алгоритмом и распараллеливать их без каких-либо дополнительных действий со стороны программиста (что обеспечивают функции без побочных эффектов — чистые функции ➤ ). Лямбда-исчисление является основой для функционального программирования, многие функциональные языки можно рассматривать как «надстройку» над ним [ 1 ] . Содержание 1 Языки функционального программирования 2 История 3 Концепции 3.1 Функции высших порядков 3.2 Чистые функции 3.3 Рекурсия 3.4 Подход к вычислению аргументов 3.5 В нефункциональных языках 4 Стили программирования 5 Особенности 5.1 Сильные стороны 5.1.1 Повышение надёжности кода 5.1.2 Удобство организации модульного тестирования 5.1.3 Возможности оптимизации при компиляции 5.1.4 Возможности параллелизма 5.2 Недостатки 6 Примечания 7 Литература 8 Ссылки Языки функционального программирования [ править | править код ] Наиболее известными языками функционального программирования являются [ 2 ] : Лисп ( Джон Маккарти , 1958 ) и множество его диалектов, наиболее известные — Scheme , Clojure и Common Lisp ; в 1970-е годы для поддержки языка создавались специализированные аппаратные комплексы — лисп-машины ; Erlang ( Джо Армстронг , 1986 ) — функциональный язык с поддержкой процессов, а также его прямой потомок Elixir ; APL — предшественник современных научных вычислительных сред, таких как MATLAB ; ML ( Робин Милнер , 1979 ) и его основные диалекты Standard ML и OCaml ; F# — функциональный язык семейства ML для платформы .NET ; Scala — язык платформы JVM , сочетающий возможности функционального и объектно-ориентированного программирования; Miranda ( Дэвид Тёрнер , 1985 ) и его прямой потомок чистый функциональный язык Haskell ; Nemerle — гибридный функционально-императивный язык. Ещё не полностью функциональные изначальные версии и Лиспа , и APL внесли особый вклад в создание и развитие функционального программирования. Более поздние версии Lisp, такие как Scheme , а также различные варианты APL поддерживали все свойства и концепции функционального языка [ 3 ] . Как правило, интерес к функциональным языкам программирования, особенно чисто функциональным, был скорее научный, нежели коммерческий. Однако, такие примечательные языки как Erlang , OCaml , Haskell , Scheme (после 1986) а также специфические R (статистика), Wolfram (символьная математика), J и K (финансовый анализ), и XSLT ( XML ) находили применение в индустрии коммерческого программирования. Такие широко распространённые декларативные языки как SQL и Lex / Yacc содержат некоторые элементы функционального программирования, например, не используют переменных. Языки работы с электронными таблицами также можно рассматривать как функциональные, потому что в ячейках электронных таблиц задаётся массив функций, как правило зависящих лишь от других ячеек, а при желании смоделировать переменные приходится прибегать к возможностям императивного языка макросов. История [ править | править код ] Лямбда-исчисление стало теоретической базой для описания и вычисления функций. Являясь математической абстракцией , а не языком программирования , оно составило базис почти всех языков функционального программирования на сегодняшний день. Сходное теоретическое понятие, комбинаторная логика , является более абстрактным, нежели λ-исчисления и было создано раньше. Эта логика используется в некоторых эзотерических языках , например в Unlambda . И λ-исчисление, и комбинаторная логика были разработаны для более ясного и точного описания принципов и основ математики [ 4 ] . Первым функциональным языком был Лисп , созданный Джоном Маккарти в период его работы в Массачусетском технологическом институте в конце пятидесятых и реализованный, первоначально, для IBM 700/7000 [ 5 ] . В Лиспе впервые введено множество понятий функционального языка, хотя при этом в языке применяется не только парадигма функционального программирования [ 6 ] . Дальнейшим развитием Лиспа стали такие языки как Scheme и Dylan . Язык обработки информации ( Information Processing Language [англ.] , IPL) иногда определяется как самый первый машинный функциональный язык [ 7 ] . Это язык ассемблерного типа для работы со списком символов. В нём было понятие «генератора», который использовал функцию в качестве аргумента, а также, поскольку это язык ассемблерного уровня, он может позиционироваться как язык, имеющий функции высшего порядка. Однако, в целом IPL акцентирован на использование императивных понятий [ 8 ] . Кеннет Айверсон разработал язык APL в начале шестидесятых, документировав его в своей книге A Programming Language ( ISBN 978-0-471-43014-8 ) [ 9 ] . APL оказал значительное влияние на язык FP [англ.] , созданный Джоном Бэкусом . В начале девяностых Айверсон и Роджер Хуэй [англ.] создали преемника APL — язык программирования J . В середине девяностых Артур Витни [англ.] , ранее работавший с Айверсоном, создал язык K , который впоследствии использовался в финансовой индустрии на коммерческой основе. В 1970-х годах в университете Эдинбурга Робин Милнер создал язык ML , а Дэвид Тернер начинал разработку языка SASL в университете Сент-Эндрюса и, впоследствии, язык Miranda в университете города Кент. В конечном итоге на основе ML были созданы несколько языков, среди которых наиболее известные Objective Caml и Standard ML . Также в семидесятых осуществлялась разработка языка программирования, построенного по принципу Scheme (реализация не только функциональной парадигмы), получившего описание в известной работе «Lambda Papers», а также в книге восемьдесят пятого года « Structure and Interpretation of Computer Programs ». В 1972 году Пер Мартин-Лёф создал интуиционистскую теорию типов (также называемую конструктивной). В этой теории функциональное программирование получило конструктивное доказательство того, что ранее было известно как зависимый тип. Это дало мощный толчок к развитию диалогового доказательства теорем и к последующему созданию множества функциональных языков. Haskell был создан в конце 1980-х годов в попытке соединить множество идей, полученных в ходе исследования функционального программирования [ 3 ] . Концепции [ править | править код ] Некоторые концепции и парадигмы специфичны для функционального программирования и в основном чужды императивному программированию (включая объектно-ориентированное программирование ). Тем не менее, языки программирования обычно представляют собой гибрид нескольких парадигм программирования, поэтому «большей частью императивные» языки программирования могут использовать какие-либо из этих концепций [ 10 ] . Функции высших порядков [ править | править код ] Основная статья: Функция высшего порядка Функции высших порядков — это такие функции, которые могут принимать в качестве аргументов и возвращать другие функции. [ 11 ] . Математики такую функцию чаще называют оператором , например, оператор взятия производной или оператор интегрирования. Функции высших порядков позволяют использовать карринг — преобразование функции от пары аргументов в функцию, берущую свои аргументы по одному. Это преобразование получило своё название в честь Хаскелла Карри . Чистые функции [ править | править код ] Чистыми называют функции, которые не имеют побочных эффектов ввода-вывода и памяти (они зависят только от своих параметров и возвращают только свой результат). Чистые функции обладают несколькими полезными свойствами, многие из которых можно использовать для оптимизации кода: если результат чистой функции не используется, её вызов может быть удалён без вреда для других выражений; результат вызова чистой функции может быть мемоизирован , то есть сохранён в таблице значений вместе с аргументами вызова; если нет никакой зависимости по данным между двумя чистыми функциями, то порядок их вычисления можно поменять или распараллелить (говоря иначе, вычисление чистых функций удовлетворяет принципам потокобезопасности ); если весь язык не допускает побочных эффектов, то можно использовать любую политику вычисления. Это предоставляет свободу компилятору комбинировать и реорганизовывать вычисление выражений в программе (например, исключить древовидные структуры). Благодаря мемоизации, если в дальнейшем функция вызывается с этими же аргументами, её результат может быть взят прямо из таблицы значений не вычисляясь (иногда это называется принципом прозрачности ссылок). Мемоизация, ценой небольшого расхода памяти, позволяет существенно увеличить производительность и уменьшить порядок роста некоторых рекурсивных алгоритмов. Хотя большинство компиляторов императивных языков программирования распознают чистые функции и удаляют общие подвыражения для вызовов чистых функций, они не могут делать это всегда для предварительно скомпилированных библиотек, которые, как правило, не предоставляют эту информацию. Некоторые компиляторы, такие как gcc , в целях оптимизации предоставляют программисту ключевые слова для обозначения чистых функций [ 12 ] . Fortran 95 позволяет обозначать функции как «pure» (чистые) [ 13 ] . Рекурсия [ править | править код ] Основная статья: Рекурсия В функциональных языках цикл обычно реализуется в виде рекурсии. Строго говоря, в функциональной парадигме программирования нет такого понятия, как цикл. Рекурсивные функции вызывают сами себя, позволяя операции выполняться снова и снова. Для использования рекурсии может потребоваться большой стек , но этого можно избежать в случае хвостовой рекурсии . Хвостовая рекурсия может быть распознана и оптимизирована компилятором в код, получаемый после компиляции аналогичной итерации в императивном языке программирования. [ 14 ] Стандарты языка Scheme требуют распознавать и оптимизировать хвостовую рекурсию. Оптимизировать хвостовую рекурсию можно путём преобразования программы в стиле использования продолжений при её компиляции, как один из способов. [ 15 ] Рекурсивные функции можно обобщить с помощью функций высших порядков, используя, например, катаморфизм и анаморфизм (или «свёртка» и «развёртка») [ 16 ] . Функции такого рода играют роль такого понятия как цикл в императивных языках программирования [ 17 ] . Подход к вычислению аргументов [ править | править код ] Функциональные языки можно классифицировать по тому, как обрабатываются аргументы функции в процессе её вычисления. Технически различие заключается в денотационной семантике выражения.
К примеру, при строгом подходе к вычислению выражения: print ( len ([ 2 + 1 , 3 * 2 , 1 / 0 , 5 - 4 ])) на выходе будет ошибка, так как в третьем элементе списка присутствует деление на ноль. При нестрогом подходе значением выражения будет 4, поскольку для вычисления длины списка значения его элементов, строго говоря, не важны и могут вообще не вычисляться. При строгом (аппликативном) порядке вычисления заранее подсчитываются значения всех аргументов перед вычислением самой функции. При нестрогом подходе (нормальный порядок вычисления) значения аргументов не вычисляются до тех пор, пока их значение не понадобится при вычислении функции [ 18 ] . Как правило, нестрогий подход реализуется в виде редукции графа. Нестрогое вычисление используется по умолчанию в нескольких чисто функциональных языках, в том числе Miranda и Haskell [ 19 ] . В нефункциональных языках [ править | править код ] Принципиально нет препятствий для написания программ в функциональном стиле на языках, которые традиционно не считаются функциональными, точно так же, как программы в объектно-ориентированном стиле можно писать на структурных языках. Некоторые императивные языки поддерживают типичные для функциональных языков конструкции, такие как функции высшего порядка и списковые включения (list comprehensions), что облегчает использование функционального стиля в этих языках, в частности, такой подход широко применяется в практике языка Python . Другим примером является язык Ruby , который имеет возможность создания как анонимных функций с использованием связанных переменных (λ-объектов), так и возможность организации анонимных функций высшего порядка через блок с помощью конструкции yield . В языке Си указатели на функцию в качестве типов аргументов могут быть использованы для создания функций высшего порядка. Функции высшего порядка и отложенная списковая структура реализованы в библиотеках C++ . В языках Java версии 8 и выше и в C# версии 3.0 и выше можно использовать λ-функции для написания программы в функциональном стиле. Стили программирования [ править | править код ] Императивные программы имеют склонность акцентировать последовательности шагов для выполнения какого-то действия, а функциональные программы к расположению и композиции функций, часто не обозначая точной последовательности шагов. Простой пример двух решений одной задачи (используется один и тот же язык Python ) иллюстрирует это. # императивный стиль target = [] # создать пустой список for item in source_list : # для каждого элемента исходного списка trans1 = G ( item ) # применить функцию G() trans2 = F ( trans1 ) # применить функцию F() target . append ( trans2 ) # добавить преобразованный элемент в список Функциональная версия выглядит по-другому: # функциональный стиль # языки ФП часто имеют встроенную функцию compose() compose2 = lambda A , B : lambda x : A ( B ( x )) target = map ( compose2 ( F , G ), source_list ) В отличие от императивного стиля, описывающего шаги, ведущие к достижению цели, функциональный стиль описывает математические отношения между данными и целью. Более точно, существует четыре ступени развития функционального стиля, в порядке убывания роли данных в программах [ источник не указан 661 день ] : Рефал (для этой категории, представленной единственным языком [ источник не указан 661 день ] , нет общепринятого названия); Аппликативные ( Лисп , ML , Tcl , Rebol ); Комбинаторные ( APL / J / K , FP [англ.] / FL [англ.] ); Бесточечные ( чистые конкатенативные ) ( Joy , Cat , Factor , подмножество PostScript ). В первом случае вся структура программы определяется структурой данных, в последнем — данные как таковые вообще отсутствуют в исходном коде, они лишь подразумеваются на входе. Некоторые языки поддерживают ряд стилей: например, Haskell позволяет писать и в аппликативном, и в комбинаторном, и в бесточечном стилях. Особенности [ править | править код ] Основной особенностью функционального программирования, определяющей как преимущества, так и недостатки данной парадигмы, является то, что в ней реализуется модель вычислений без состояний. Если императивная программа на любом этапе исполнения имеет состояние, то есть совокупность значений всех переменных, и производит побочные эффекты, то чисто функциональная программа ни целиком, ни частями состояния не имеет и побочных эффектов не производит. То, что в императивных языках делается путём присваивания значений переменным, в функциональных достигается путём передачи выражений в параметры функций. Непосредственным следствием становится то, что чисто функциональная программа не может изменять уже имеющиеся у неё данные, а может лишь порождать новые путём копирования или расширения старых. Следствием того же является отказ от циклов в пользу рекурсии. Сильные стороны [ править | править код ] Повышение надёжности кода [ править | править код ] Привлекательная сторона вычислений без состояний — повышение надёжности кода за счёт чёткой структуризации и отсутствия необходимости отслеживания побочных эффектов. Любая функция работает только с локальными данными и работает с ними всегда одинаково, независимо от того, где, как и при каких обстоятельствах она вызывается. Невозможность мутации данных при пользовании ими в разных местах программы исключает появление труднообнаруживаемых ошибок (таких, например, как случайное присваивание неверного значения глобальной переменной в императивной программе). Удобство организации модульного тестирования [ править | править код ] Поскольку функция в функциональном программировании не может порождать побочные эффекты, менять объекты нельзя как внутри области видимости, так и снаружи (в отличие от императивных программ, где одна функция может установить какую-нибудь внешнюю переменную, считываемую второй функцией). Единственным эффектом от вычисления функции является возвращаемый ей результат, и единственный фактор, оказывающий влияние на результат — это значения аргументов. Таким образом, имеется возможность протестировать каждую функцию в программе, просто вычислив её от различных наборов значений аргументов. При этом можно не беспокоиться ни о вызове функций в правильном порядке, ни о правильном формировании внешнего состояния. Если любая функция в программе проходит модульные тесты, то можно быть уверенным в качестве всей программы. В императивных программах проверка возвращаемого значения функции недостаточна: функция может модифицировать внешнее состояние, которое тоже нужно проверять, чего не нужно делать в функциональных программах [ 20 ] . Возможности оптимизации при компиляции [ править | править код ] Традиционно упоминаемой положительной особенностью функционального программирования является то, что оно позволяет описывать программу в так называемом «декларативном» виде, когда жесткая последовательность выполнения многих операций, необходимых для вычисления результата, в явном виде не задаётся, а формируется автоматически в процессе вычисления функций. Это обстоятельство, а также отсутствие состояний даёт возможность применять к функциональным программам достаточно сложные методы автоматической оптимизации. Возможности параллелизма [ править | править код ] Ещё одним преимуществом функциональных программ является то, что они предоставляют широчайшие возможности для автоматического распараллеливания вычислений. Поскольку отсутствие побочных эффектов гарантировано, в любом вызове функции всегда допустимо параллельное вычисление двух различных параметров — порядок их вычисления не может оказать влияния на результат вызова. Недостатки [ править | править код ] Недостатки функционального программирования вытекают из тех же самых его особенностей. Отсутствие присваиваний и замена их на порождение новых данных приводят к необходимости постоянного выделения и автоматического освобождения памяти, поэтому в системе исполнения функциональной программы обязательным [ источник не указан 1522 дня ] компонентом становится высокоэффективный сборщик мусора . Нестрогая модель вычислений приводит к непредсказуемому порядку вызова функций, что создаёт проблемы при вводе-выводе, где порядок выполнения операций важен. Кроме того, очевидно, функции ввода в своём естественном виде (например, getchar() из стандартной библиотеки языка Си ) не являются чистыми, поскольку способны возвращать различные значения для одних и тех же аргументов, и для устранения этого требуются определённые ухищрения. Для преодоления недостатков функциональных программ уже первые языки функционального программирования включали не только чисто функциональные средства, но и механизмы императивного программирования (присваивание, цикл, «неявный PROGN» были уже в Лиспе). Использование таких средств позволяет решить некоторые практические проблемы, но означает отход от идей (и преимуществ) функционального программирования и написание императивных программ на функциональных языках. В чистых функциональных языках эти проблемы решаются другими средствами, например, в языке Haskell ввод-вывод реализован при помощи монад — концепции, позаимствованной из теории категорий. Примечания [ править | править код ] ↑ А. Филд, П. Харрисон Функциональное программирование: Пер. с англ. — М.: Мир, 1993. — 637 с, ил. ISBN 5-03-001870-0 . Стр. 120 [Глава 6: Математические основы: λ-исчисление]. ↑ Tiobe Programming Community Index (неопр.) . Дата обращения: 24 сентября 2011. Архивировано 2 июля 2013 года. ↑ 1 2 Пол Хьюдак [англ.] . Conception, evolution, and application of functional programming languages (англ.) // Association for Computing Machinery Computing Surveys : journal. — 1989. — September ( vol. 21 , no. 3 ). — P. 359—411 . — doi : 10.1145/72551.72554 . Архивировано 5 июня 2013 года. ↑ Роджер Пенроуз . Глава 2: Лямбда-исчисление Черча // Новый ум короля. О компьютерах, мышлении и законах физики = The Emperors New Mind: Concerning Computers, Minds and The Laws of Physics. — Едиториал УРСС, 2003. — ISBN 5-354-00005-X . + переиздание ISBN 978-5-382-01266-7 ; 2011 г. ↑ McCarthy, John [англ.] . History of Lisp // In Association for Computing Machinery SIGPLAN History of Programming Languages Conference. — 1978. — Июнь. — С. 217—223 . — doi : 10.1145/800025.808387 . Архивировано 7 июня 2008 года. ↑ J. Harrison, 1997 , Гл. 3. λ-исчисление как язык программирования. ↑ В своих мемуарах Герберт Саймон (1991), Models of My Life pp.189-190 ISBN 0-465-04640-1 утверждает, что его, Al. Ньюэлл, и Клифф Шоу которых «часто называют родителями искусственного интеллекта» за написание программы Logic Theorist [англ.] автоматически доказывающей теоремы из Principia Mathematica . Для того, чтобы достичь этого, они должны были придумать язык и парадигму, которую, ретроспективно, можно рассматривать как функциональное программирование. ↑ History of Programming Languages: IPL (неопр.) . Дата обращения: 15 апреля 2012. Архивировано из оригинала 1 ноября 2006 года. ↑ XIV. APL Session // History of Programming Language / Richard L. Wexelbblat. — Academic Press, 1981. — С. 661 —693. — 749 с. — ISBN 0-12-745040-8 . ↑ Евгений Кирпичёв. Элементы функциональных языков // Практика функционального программирования. — 2009. — Декабрь ( вып. 3 ). — ISSN 2075-8456 . Архивировано 3 сентября 2017 года. ↑ Скачать PDF: «Техники функционального программирования, В. А. Потапенко» стр. 8 «Функции высших порядков» (неопр.) . Дата обращения: 10 января 2009. Архивировано 30 июня 2009 года. ↑ GCC, Declaring Attributes of Functions (неопр.) . Дата обращения: 28 августа 2012. Архивировано 18 августа 2012 года. ↑ XL Fortran for AIX, V13.1 > Language Reference, Pure procedures (Fortran 95) ↑ Tail call optimization (неопр.) . Дата обращения: 31 июля 2012. Архивировано 1 августа 2012 года. ↑ Revised5 Report on the Algorithmic Language Scheme, 3.5. Proper tail recursion (неопр.) . Дата обращения: 31 июля 2012. Архивировано 5 января 2007 года. ↑ Meijer, Erik ; Fokkinga, Maarten; Paterson, Ross (1991). Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (PDF) . Conference on Functional Programming Languages and Computer Architecture (FPCA). Springer. pp. 124– 144. CiteSeerX 10.1.1.41.125 . ISBN 3-540-54396-1 . Архивировано (PDF) 9 июля 2017 . Дата обращения: 3 марта 2020 . ↑ Bird, Richard. Pearls of Functional Algorithm Design (англ.) . — Cambrigde : University Press , 2010. — 277 p. — ISBN 978-0-521-51338-8 . Архивировано 8 марта 2022 года. ↑ Н. А. Роганова Функциональное программирование: Учебное пособие для студентов высших учебных заведений — М.: ГИНФО, 2002. — 260 с. Стр. 14 п. 3.1. Ленивые и энергичные вычисления ↑ Lazy Evaluation - an overview | ScienceDirect Topics (неопр.) . www.sciencedirect.com . Дата обращения: 23 марта 2021. ↑ Ахмечет В. «Функциональное программирование для всех» (неопр.) . Дата обращения: 11 января 2009. Архивировано 2 февраля 2009 года. Литература [ править | править код ] Городняя Л. В. Основы функционального программирования. Курс лекций — М.: Интернет-университет информационных технологий, 2004. С. 280. ISBN 5-9556-0008-6 Душкин Р. В. Функциональное программирование на языке Haskell. — М.: ДМК Пресс, 2006. С. 608. ISBN 5-94074-335-8 Филд А., Харрисон П. Функциональное программирование = Functional Programming. — М. : Мир, 1993. — 637 с. — ISBN 5-03-001870-0 . Н. А. Роганова Функциональное программирование: Учебное пособие для студентов высших учебных заведений — М.: ГИНФО, 2002. — 260 с. John Harrison. Функциональное программирование. Курс лекций = Functional Programming . — 1997. А. М. Миронов. Теория функциональных программ. Ссылки [ править | править код ] Имеется викиучебник по теме « Основы функционального программирования » Журнал «Практика функционального программирования» (выпускался в 2009—2011 годы) Ссылки на внешние ресурсы Тематические сайты nLab Словари и энциклопедии Britannica (онлайн) В библиографических каталогах BNE : XX547935 BNF : 121910539 GND : 4198740-8 J9U : 987007541542105171 LCCN : sh87007844 NKC : ph572639 Для улучшения этой статьи желательно : Проставить сноски , внести более точные указания на источники. После исправления проблемы исключите её из списка. Удалите шаблон, если устранены все недостатки. Источник — https://ru.wikipedia.org/w/index.php?title=Функциональное_программирование&oldid=140252537 Категории : Функциональное программирование Рекурсия Скрытые категории: Страницы, использующие устаревший тег source Википедия:Cite web (не указан язык) Страницы, использующие волшебные ссылки ISBN Википедия:Статьи без источников (не распределённые по типам) Википедия:Нет источников с июня 2023 Википедия:Статьи с утверждениями без источников более 14 дней Википедия:Нет источников с января 2021 Википедия:Ссылка на Викиучебник непосредственно в статье Википедия:Статьи без сносок Википедия:Статьи с шаблонами недостатков по алфавиту Статьи с примерами кода Python Навигация Поиск